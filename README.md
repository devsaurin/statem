# StateM

## Introduction
StateM is [Mealy State Machine](https://en.wikipedia.org/wiki/Mealy_machine) written in TypeScript and is largely based on Erlang OTP’s [gen\_statem](http://erlang.org/doc/design_principles/statem.html#event-time-outs "gen\_statem") behavior.

[![](https://img.shields.io/badge/demo-online-green.svg)](https://hotel-safe.netlify.com/#/)

State machines are specified as an ordered list of handlers keyed by `Event x State` patterns. Events drive the state machine and are externally triggered or internally generated by the state machine. Pending events are  tracked on a priority queue that preserves entry order. State machines can hold arbitrary [data](#) which is provided to, and can be mutated by, its event handlers.

## Features
* **Co-located code**: Event, states, transitions and actions in one place.
* **Inserted Events**: Insert events from within the specification.
* **State Entry Events**: Automatically generates Entry events on state change.
* **Timeouts**: Install timeouts for state transitions, new events, or just plain timeouts.

## Installation
Install with `npm`:

```bash
npm install --save gen-statem
```
## Usage

### Create a StateMachine 
You can create a state machine by calling `StateMachine's` constructor and passing it a list of handlers, the initial state and optional data.

> Note: The state machine’s data type `TData` is a  type argument (`StateMachine<TData>`).

For example, the state machine below toggles states 
`ONE` and `TWO` on event `next`.
![](https://documents.lucidchart.com/documents/eef39cb2-9656-4c52-88d8-eb6c9f6a5cec/pages/YGcM5DNywbTK?a=1152&x=85&y=151&w=360&h=181&store=1&accept=image/*&auth=LCA%20a77efaa9c861072b1008c96fd065a7b008f5aa33-ts=1538363749)
```ts
let sm = new StateMachine<void>({
    handlers: [
        ['cast#next#ONE', 'TWO'],
        ['cast#next#TWO', () => nextState('ONE')],
    ],
    initialState: "ONE",
})

sm.startSM()

sm.on('stateChanged', (state, old, data, event) => {
    console.log(`${old} --> ${state} on ${event ? event.toString() : ''}`)
})

sm.cast('next')
// ONE --> TWO on Cast@Low { context: 'next' }

sm.cast('next')
// TWO --> ONE on Cast@Low { context: 'next' }



```



### Subclassing StateMachine 
Extending the `StateMachine` class lets you:
* Declare and implement a public API for your state machine (and wrap call/cast dispatch calls). 
* Provide helper functions. 

> Note: Handler functions are called with `this` set to the state machine instance.

```ts
class PingPong extends StateMachine<void> {
    handlers: Handlers<void> = [
        ['cast#next#ONE', 'TWO'],
        ['cast#next#TWO', 'ONE'],
    ]

    initialState = "ONE"

    // Define our public API
    next() {
        this.cast('next')
    }
}

let sm = new PingPong()
sm.startSM()

sm.on('stateChanged', (state, old, data, event) => {
    console.log(`${old} --> ${state} on ${event ? event.toString() : ''}`)
})

sm.next()
// ONE --> TWO on Cast@Low { context: 'next' }

sm.next()
// TWO --> ONE on Cast@Low { context: 'next' }
```
## Details

### Routes
StateM uses the url path to parameterized route matching seen in [express](www.expressjs.com) et. al. 

#### Current Event Routes
The current event and current state are mapped to a route string as:
```
<current event>#<event context>#<current state>
```

For example:

| Event | Event Context | Current State | Route |
|-|-|-|-|
| cast | `"flip"` | off | `"cast#flip#off"` |
| cast | `{button: 2}` | locked | `"cast#button/2#off"` |
| call | `"getInfo"` | one | `"call/internalId#getInfo/2#one"` |




#### Event Handler Routes
In addition to string literals, handler routes can include:
* Parameter capture patterns (`:param`) capture up to the next `/`, `#` or the end of the route.
* Splats (`*param`) capture from up to `#` or the end of the route.
* Parts of the route can be marked optional by wrapping in parenthesis. Optional parts can include parameter capture and splats.

For example:
* `cast#flip#:state` will match a `cast(flip)` event in any state and provide the current state as an argument (`args.param`) to the handler. 
* `call/:from#getInfo#:state` will capture the callerId and state as `args.from` and `args.state` respectively.
* `"cast#button/:digit#locked` will capture a button press in the `locked` state and provide the digit value in `args.digit`.
* `"cast#*context#open` intercepts any `cast` events in state `open` regardless of the parameters passed when cast was invoked (note: the splat will be available as `args.context`).





### Event Handlers
A key part of a state machine specification is the list of (route, handler) tuples:

```
(string | Array<string>, function | string | [string, string | number])
```

> Note: Event handlers are specified as an array to  preserve order (vs. objects, where property[iteration order](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in#Deleted_added_or_modified_properties) is arbitrary).

#### Multiple Routes to a Handler
When a route is specified as an array, it is treated as a boolean OR, i.e. if any route matches an incoming event route, the corresponding handler is invoked.


#### Handler Functions
Handler functions receive the following:
```ts
type HandlerOpts<TData> = {
    args: { [k in string]: string },
    current: State,
    data: TData,
    event: Event,
    route: string
}
```

* `current`: the state machine’s current state.
* `data`: the state machine’s current data.
* `args`: any arguments or splats parsed from the incoming event’s route.
* `event`: the actual incoming event.
* `route`: the event’s route.

Handler functions can return:
* `ResultBuilder` a fluent builder for `Results`.
* `Result` - verbose, not recommended.
* `void` - interpreted as `keepStateAndData`


#### `string` Handlers
Instead of a handler function, you can provide a 
* `state: string` - interpreted as a next state directive.
* `[state: string, timeout: string | number]` - interpreted as a next state directive and event timeout.

### Result Builder
StateM provides a fluent interface (`ResultBuilder`)  for specifying state transitions and actions in handler functions.

The following functions return a `ResultBuilder`:
* [keepState](#): Instructs the state machine to keep the current state (i.e. transition to the same state). Does not emit a state entry event. 
* [repeatState](#): Like `keepState`, but emits a state entry event. 
* [nextState(state)](#): Instructs the state machine to transition to the given `state` (can be the current state).


#### ResultBuilder Methods
`ResultBuilders` provide the following chainable methods:

* [data(spec)](#): Instructs the state machine to mutate state data with the given `spec`.
* [eventTimeout(time)](#): Starts the event timer which may result in a `EventTimeoutEvent` event if a new event is not received.
* [stateTimeout(time)](#): Starts the state timer which may result in a `StateTimeoutEvent` event if a state transition does not occur.
* [timeout(time, name)](#): Starts a generic timer with an optional name which may result in a `GenericTimeoutEvent`. Calling `timeout(name)` will cancel the event if it has not yet fired.
* [nextEvent(type, context, extra)](#): Inserts an event of the given type at the front of the queue so that it is executed before pending events.
* [internalEvent(context, extra)](#): Like `nextEvent`, this method inserts an `InternalEvent` event.
* [postpone](#): Instructs the state machine to postpone the current until the state changes at which point any postponed events are delivered before pending events.
* [reply(from, msg)](#): Instructs the state machine to reply to the sender with id `from`; the result of  a prior invocation of `call`. 


### Mutating State Machine Data
State machine data is mutated by calling the `data` on `ResultBuilder` with [immutability-helper](#) commands, including:
* `{$push: array}` `push()` all the items in `array` on the target.
  * `{$unshift: array}` `unshift()` all the items in `array` on the target.
  * `{$splice: array of arrays}` for each item in `arrays` call `splice()` on the target with the parameters provided by the item. Note: The items in the array are applied sequentially, so the order matters. The indices of the target may change during the operation.*   * `{$set: any}` replace the target entirely.
  * `{$toggle: array of strings}` toggles a list of boolean fields from the  target object.
  * `{$unset: array of strings}` remove the list of keys in `array` from the target object.
  * `{$merge: object}` merge the keys of `object` with the target.
  * `{$apply: function}` passes in the current value to the function and updates it with the new returned value.
  * `{$add: array of objects}` add a value to a `Map` or `Set`. When adding to a `Set` you pass in an array of objects to add, when adding to a Map, you pass  in `[key, value]` arrays like so:
  `update(myMap, {$add: [['foo', 'bar'], ['baz', 'boo']]})`
  * `{$remove: array of strings}` remove the list of keys in array from a `Map` or `Set`.

# Event Types
* [CallEvent](docs/classes/callevent.md)
* [CastEvent](docs/classes/castevent.md)
* [PostponeEvent](docs/classes/postponeevent.md)
* [EnterEvent](docs/classes/enterevent.md)
* [EventTimeoutEvent](docs/classes/eventtimeoutevent.md)
* [GenericTimeoutEvent](docs/classes/generictimeoutevent.md)
* [InternalEvent](docs/classes/internalevent.md)
* [StateTimeoutEvent](docs/classes/statetimeoutevent.md)

## Processing Events
The state machine looks for the first event handler whose key matches the `incoming event x current state`, or, a catch-all handler. 

The matched handler is invoked with the incoming event, route matching arguments, the current state machine state and data. 

The result of the handler invocation can include a state transition directive and transition actions, which are immediately executed, potentially changing the state machine’s state, mutating the internal data as well as the event queue. 


## Complex State

## Examples
See the `examples` directory for more examples.




### Toggle Button
ToggleButton is a simple state machine of a button that toggles between `off` and `on` when it’s toggle is flipped. It’s initial state is `off`.

```ts
class ToggleButton extends StateMachine {
	initialState = 'off'

	handlers: Handlers = [
		['cast#flip#off', 'on'],
		['cast#flip#on', 'off']
	]

	flip() {
		this.cast('flip')
	}
}
```

ToggleButton has a single event as its input, `cast('flip')` and no state transition actions. 

1. `'cast#flip#off` —\> `on`
	i.e. in state `off`, if we receive event `cast('flip')`, transition to state `on`.

2. `'cast#flip#on` —\> `of` 
	i.e. in state `on`, if we receive event `cast('flip')`, transition to state `off`.

```ts
let button = new ToggleButton()
button.startSM()

// initial state
console.log(await button.getState())	// 'off'

button.flip()
console.log(await button.getState())	// 'on'

button.flip()
console.log(await button.getState())	// 'off'
```
### Toggle Button With Count
ToggleButtonCount adds a counter to [ToggleButton](#) that counts the number of times it turned on.

```ts
export class ToggleButtonWithCount extends StateMachine {
	initialState = 'off'

	data = {
		count: 0
	}

	handlers: Handlers = [
		['cast#flip#off', ({data}) => nextState('on')
			.data({count: {$set: data.count + 1}})],

		['cast#flip#on', 'off']
	]

	flip() {
		this.cast('flip')
	}
}
```

ToggleButtonWith count adds a transition action when exiting `off` state.


```ts
let button = new ToggleButton()
button.startSM()

// initial state
console.log(await button.getState())	// 'off'

button.flip()
console.log(await button.getState())	// 'on'

button.flip()
console.log(await button.getState())	// 'off'
```
