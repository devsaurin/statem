# StateM
StateM is Mealy state machine written in TypeScript and is largely based on
Erlang OTP’s [gen_statem](http://erlang.org/doc/design_principles/statem.html#State%20Transition%20Actions) behavior.

An ordered list of event handlers keyed to `Event x State` combinations forms the core specification of the state machine.

* States are arbitrary strings.

* Events drive transitions between states. Events can  either be externally
triggered or internally generated by the state machine and are maintained
on a stable priority queue.

* Data: The state machine can hold arbitrary data which is provided to, and can be mutated by, its event handlers.

To process an event, the state machine looks for the first event handler whose
key matches the `IncomingEvent x CurrentState` (else, it matches a catch all
handler). The matched handler is invoked with the incoming event and current
state and data.

The result of a handler invocation can include a state transition directive and transition actions, which are immediately executed, potentially changing the state
machine’s state, mutating the internal data as well as the event queue.

## Features
* Co-located code: All event specifications and handler code in one place.
* Inserted Events: Insert events from within the specification.
* State Entry Events: Automatically generates Entry events on state change.
* Timeouts: Install timeouts for state transitions, new events, or just plain timeouts.

# Examples
## Toggle Button
ToggleButton is a simple state machine of a button that toggles between `off` and `on` when it’s toggle is flipped. It’s initial state is `off`.

```TypeScript

export class ToggleButton extends StateMachine<void> {
    initialState = 'off'

    handlers: Handlers<void> = [
        ['cast#flip#off', 'on'],
        ['cast#flip#on', 'off']
    ]

    flip() {
        this.cast('flip')
    }
}
```

ToggleButton has a single event as its input, `cast('flip')` and no state transition actions.

### Specification
1. `'cast#flip#off` —> `on`
	i.e. in state `off`, if we receive event `cast('flip')`, transition to state `on`.

2. `'cast#flip#on` —> `of`
	i.e. in state `on`, if we receive event `cast('flip')`, transition to state `off`.

```
let button = new ToggleButton()
button.startSM()

// initial state
console.log(await button.getState())	// 'off'

button.flip()
console.log(await button.getState())	// 'on'

button.flip()
console.log(await button.getState())	// 'off'

```

## A Hotel Safe

```TypeScript
type SafeData = {
    code: Array<number>,
    input: Array<number>,
    codeTimeout: Timeout,
    msgDisplay: Timeout,
    codeSize: number
}

export default class HotelSafe extends StateMachine<SafeData> {
    initialState = 'open'

    handlers: Handlers<SafeData> = [

        // Clear data when safe enters OPEN
        ['enter#*_#open', () =>
            keepState().data({code: {$set: []}, input: {$set: []}})],

        // User pressed RESET -- go to LOCKING
        ['cast#reset#open', 'locking'],

        // Timeout from LOCKING if inactive
        ['enter#*_#locking', ({data}) =>
            keepState().eventTimeout(data.codeTimeout)],

        // Track the last {codeSize} digits.
        ['cast#button/:digit#locking', ({args, data}) => {
            let code = pushFixed(Number(args.digit), data.code, data.codeSize)
            return keepState()
                .data({code: {$set: code}})
                .eventTimeout(data.codeTimeout)
        }],

        // Back to OPEN if inactive timer fires
        ['eventTimeout#time/:time#locking', 'open'],

        // User pressed LOCK. CLose safe if code is long enough
        // else ignore
        ['cast#lock#locking', ({data}) =>
            data.code.length === data.codeSize ?
            nextState('closed') :
            keepState()],

        // User entered digit(s).
        // Keep state if code is not long enough
        // OPEN if input matches code
        // go to MESSAGE if code does not match and set a timeout
        ['cast#button/:digit#closed', ({args, data}) => {
            let digit = Number(args.digit)
            let input = data.input.concat(digit)
            return input.length < data.code.length ?
                   keepState().data({input: {$push: [digit]}}) :
                   arrayEqual(data.code, input) ?
                   nextState('open') :
                   nextState('closed/message').timeout(data.msgDisplay)
        }],

        ['genericTimeout#*_#closed/message', 'closed'],
    ]

    initialData: SafeData = {
        code: [],
        codeSize: 4,
        codeTimeout: 200,
        input: [],
        msgDisplay: 200,
    }

    constructor(timeout: Timeout) {
        super()
        this.initialData.codeTimeout = timeout
        this.initialData.msgDisplay = timeout
    }

    reset() {
        this.cast('reset')
    }

    lock() {
        this.cast('lock')
    }

    button(digit: number) {
        this.cast({button: digit})
    }
}
```
