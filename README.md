# StateM

## Introduction
StateM is [Mealy State Machine](https://en.wikipedia.org/wiki/Mealy_machine) written in TypeScript and is largely based on Erlang OTP’s [gen\_statem](http://erlang.org/doc/design_principles/statem.html#event-time-outs "gen\_statem") behavior.

[![](https://img.shields.io/badge/demo-online-green.svg)](https://hotel-safe.netlify.com/#/)

State machines are specified as an ordered list of handlers keyed by `Event x State` patterns. Events drive the state machine and are externally triggered or internally generated by the state machine. Pending events are  tracked on a priority queue that preserves entry order. State machines can hold arbitrary [data](#) which is provided to, and can be mutated by, its event handlers.

## Features
* **Co-located code**: Event, states, transitions and actions in one place.
* **Inserted Events**: Insert events from within the specification.
* **State Entry Events**: Automatically generates Entry events on state change.
* **Timeouts**: Install timeouts for state transitions, new events, or just plain timeouts.

## Installation
Install with `npm`:

```bash
npm install --save gen-statem
```
## Usage

### Create a StateMachine 
You can create a state machine by calling `StateMachine's` constructor and passing it a list of handlers, the initial state and optional data.

> Note: The state machine’s data type `TData` is a  type argument (`StateMachine<TData>`).

For example, the state machine below toggles states 
`ONE` and `TWO` on event `next`.
![](https://documents.lucidchart.com/documents/eef39cb2-9656-4c52-88d8-eb6c9f6a5cec/pages/YGcM5DNywbTK?a=1152&x=85&y=151&w=360&h=181&store=1&accept=image/*&auth=LCA%20a77efaa9c861072b1008c96fd065a7b008f5aa33-ts=1538363749)
```ts
let sm = new StateMachine<void>({
    handlers: [
        ['cast#next#ONE', 'TWO'],
        ['cast#next#TWO', () => nextState('ONE')],
    ],
    initialState: "ONE",
})

sm.startSM()

sm.on('stateChanged', (state, old, data, event) => {
    console.log(`${old} --> ${state} on ${event ? event.toString() : ''}`)
})

sm.cast('next')
// ONE --> TWO on Cast@Low { context: 'next' }

sm.cast('next')
// TWO --> ONE on Cast@Low { context: 'next' }



```



### Subclassing StateMachine 
Extending the `StateMachine` class lets you:
* Declare and implement a public API for your state machine (and wrap call/cast dispatch calls). 
* Provide helper functions. 

> Note: Handler functions are called with `this` set to the state machine instance.

```ts
class PingPong extends StateMachine<void> {
    handlers: Handlers<void> = [
        ['cast#next#ONE', 'TWO'],
        ['cast#next#TWO', 'ONE'],
    ]

    initialState = "ONE"

    // Define our public API
    next() {
        this.cast('next')
    }
}

let sm = new PingPong()
sm.startSM()

sm.on('stateChanged', (state, old, data, event) => {
    console.log(`${old} --> ${state} on ${event ? event.toString() : ''}`)
})

sm.next()
// ONE --> TWO on Cast@Low { context: 'next' }

sm.next()
// TWO --> ONE on Cast@Low { context: 'next' }
```
## Details

### Routes
StateM uses the url path to parameterized route matching seen in [express](www.expressjs.com) et. al. 

#### Current Event Routes
The current event and current state are mapped to a route string as:
```
<current event>#<event context>#<current state>
```

For example:

| Event | Event Context | Current State | Route |
|-|-|-|-|
| cast | `"flip"` | off | `"cast#flip#off"` |
| cast | `{button: 2}` | locked | `"cast#button/2#off"` |
| call | `"getInfo"` | one | `"call/internalId#getInfo/2#one"` |




#### Event Handler Routes
In addition to string literals, handler routes can include:
* Parameter capture patterns (`:param`) capture up to the next `/`, `#` or the end of the route.
* Splats (`*param`) capture from up to `#` or the end of the route.
* Parts of the route can be marked optional by wrapping in parenthesis. Optional parts can include parameter capture and splats.

For example:
* `cast#flip#:state` will match a `cast(flip)` event in any state and provide the current state as an argument (`args.param`) to the handler. 
* `call/:from#getInfo#:state` will capture the callerId and state as `args.from` and `args.state` respectively.
* `"cast#button/:digit#locked` will capture a button press in the `locked` state and provide the digit value in `args.digit`.
* `"cast#*context#open` intercepts any `cast` events in state `open` regardless of the parameters passed when cast was invoked (note: the splat will be available as `args.context`).





### Event Handlers
A key part of a state machine specification is the list of (route, handler) tuples:

```
(string | Array<string>, function | string | [string, string | number])
```

> Note: Event handlers are specified as an array to  preserve order (vs. objects, where property[iteration order](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in#Deleted_added_or_modified_properties) is arbitrary).

#### Multiple Routes to a Handler
When a route is specified as an array, it is treated as a boolean OR, i.e. if any route matches an incoming event route, the corresponding handler is invoked.


#### Handler Functions
Handler functions receive the following:
```ts
type HandlerOpts<TData> = {
    args: { [k in string]: string },
    current: State,
    data: TData,
    event: Event,
    route: string
}
```

* `current`: the state machine’s current state.
* `data`: the state machine’s current data.
* `args`: any arguments or splats parsed from the incoming event’s route.
* `event`: the actual incoming event.
* `route`: the event’s route.

Handler functions can return:
* `ResultBuilder` a fluent builder for `Results`.
* `Result` - verbose, not recommended.
* `void` - interpreted as `keepStateAndData`


#### `string` Handlers
Instead of a handler function, you can provide a 
* `state: string` - interpreted as a next state directive.
* `[state: string, timeout: string | number]` - interpreted as a next state directive and event timeout.

### Result Builder
StateM provides a fluent interface (`ResultBuilder`)  for specifying state transitions and actions in handler functions.

The following functions return a `ResultBuilder`:
* [keepState](#): Instructs the state machine to keep the current state (i.e. transition to the same state). Does not emit a state entry event. 
* [repeatState](#): Like `keepState`, but emits a state entry event. 
* [nextState(state)](#): Instructs the state machine to transition to the given `state` (can be the current state).


#### ResultBuilder Methods
`ResultBuilders` provide the following chainable methods:

* [data(spec)](#): Instructs the state machine to mutate state data with the given `spec`.
* [eventTimeout(time)](#): Starts the event timer which may result in a `EventTimeoutEvent` event if a new event is not received.
* [stateTimeout(time)](#): Starts the state timer which may result in a `StateTimeoutEvent` event if a state transition does not occur.
* [timeout(time, name)](#): Starts a generic timer with an optional name which may result in a `GenericTimeoutEvent`. Calling `timeout(name)` will cancel the event if it has not yet fired.
* [nextEvent(type, context, extra)](#): Inserts an event of the given type at the front of the queue so that it is executed before pending events.
* [internalEvent(context, extra)](#): Like `nextEvent`, this method inserts an `InternalEvent` event.
* [postpone](#): Instructs the state machine to postpone the current until the state changes at which point any postponed events are delivered before pending events.
* [reply(from, msg)](#): Instructs the state machine to reply to the sender with id `from`; the result of  a prior invocation of `call`. 


### Mutating State Machine Data
State machine data is mutated by calling the `data` on `ResultBuilder` with [immutability-helper](#) commands, including:

* `{$push: array}` `push()` all the items in `array` on the target.
  * `{$unshift: array}` `unshift()` all the items in `array` on the target.
  * `{$splice: array of arrays}` for each item in `arrays` call `splice()` on the target with the parameters provided by the item. Note: The items in the array are applied sequentially, so the order matters. The indices of the target may change during the operation.*   * `{$set: any}` replace the target entirely.
  * `{$toggle: array of strings}` toggles a list of boolean fields from the  target object.
  * `{$unset: array of strings}` remove the list of keys in `array` from the target object.
  * `{$merge: object}` merge the keys of `object` with the target.
  * `{$apply: function}` passes in the current value to the function and updates it with the new returned value.
  * `{$add: array of objects}` add a value to a `Map` or `Set`. When adding to a `Set` you pass in an array of objects to add, when adding to a Map, you pass  in `[key, value]` arrays like so:
  `update(myMap, {$add: [['foo', 'bar'], ['baz', 'boo']]})`
  * `{$remove: array of strings}` remove the list of keys in array from a `Map` or `Set`.

# Event Types
* [CallEvent](docs/classes/callevent.md)
* [CastEvent](docs/classes/castevent.md)
* [PostponeEvent](docs/classes/postponeevent.md)
* [EnterEvent](docs/classes/enterevent.md)
* [EventTimeoutEvent](docs/classes/eventtimeoutevent.md)
* [GenericTimeoutEvent](docs/classes/generictimeoutevent.md)
* [InternalEvent](docs/classes/internalevent.md)
* [StateTimeoutEvent](docs/classes/statetimeoutevent.md)

## Processing Events
The state machine looks for the first event handler whose key matches the `incoming event x current state`, or, a catch-all handler. 

The matched handler is invoked with the incoming event, route matching arguments, the current state machine state and data. 

The result of the handler invocation can include a state transition directive and transition actions, which are immediately executed, potentially changing the state machine’s state, mutating the internal data as well as the event queue. 


## Complex State

## Examples
See the `examples` directory for more examples.

### Toggle Button With Count
ToggleButtonCount maintains a counter in the state machine’s data that counts the number of times it turned on.

```ts
type ToggleButtonWithCountData = {
    count: number
}

export class ToggleButtonWithCount
    extends StateMachine<ToggleButtonWithCountData> {
    initialState = 'off'

    handlers: Handlers<ToggleButtonWithCountData> = [
        // if we get 'flip' in 'off', go to 'on'
        // and increment data.count
        ['cast#flip#off', ({data}) => nextState('on')
            .data({count: {$set: data.count + 1}})],
        
		// flip from on goes back to off.
		['cast#flip#on', 'off']
    ]

    initialData: ToggleButtonWithCountData = {
        count: 0
    }

    flip() {
        this.cast('flip')
    }
}
```


```ts
let button = new ToggleButton()
button.startSM()

// initial state
console.log(await button.getState())	// 'off'

button.flip()
console.log(await button.getState())	// 'on'

button.flip()
console.log(await button.getState())	// 'off'
```
### Push Button Countdown Timer
PushButtonCountdownTimer turns on when pushed and starts a `genericTimeout`. The button turns off when the timer fires.

```ts
type PushButtonCountdownTimerData = {
    timeout: Timeout
}

class PushButtonCountdownTimer extends StateMachine<PushButtonCountdownTimerData> {
    initialState = 'off'

    handlers: Handlers<PushButtonCountdownTimerData> = [
		// Start a generic timer and go to 'on'
        ['cast#push#off', ({data}) => nextState('on').timeout(data.timeout)],

		// when we get 'genericTimeout' in 'on', 
		// go back to 'off'
        ['genericTimeout#*_#on', 'off']
    ]

    constructor(timeout: Timeout) {
        super()
        this.initialData = {timeout}
    }

    push() {
        this.cast('push')
    }
}
```
### A Hotel Safe
See [![](https://img.shields.io/badge/demo-online-green.svg)](https://hotel-safe.netlify.com/#/)
`HotelSafe` simulates a type of safe frequently seen in hotel rooms. 

* **Locking the Safe**
	* Press Reset (R). The display will prompt for a new code. 
	* Enter a 4 digit code and then press Lock (L).
	* The code will flash. The safe is now locked.

* **Unlocking the Safe**
	* Enter the 4 digit code.
	* The safe will flash OPENED if the code is correct. The safe is now open.
	* If the code is incorrect, the display will flash ERROR and the safe will stay locked.


```ts

/**
 * The state machine's data type
 */
type SafeData = {
    code: Array<number>,
    input: Array<number>,
    timeout: Timeout,
    codeSize: number,
    message?: string
}

export default class HotelSafe extends StateMachine<SafeData> {
    handlers: Handlers<SafeData> = [

        // Clear data when safe enters OPEN
        ['enter#*_#open', () => keepState().data({
            code: {$set: []},
            input: {$set: []},
            message: {$set: 'Open'},
        })],

        // User pressed RESET -- get new code
        ['cast#reset#open', () => nextState('open/locking').data({
            message: {$set: 'Enter Code'},
        })],

        // Track the last {codeSize} digits.
        // show code on display. Repeat state for setting timeout
        ['cast#button/:digit#open/locking', ({args, data}) => {
            let code = pushFixed(Number(args.digit), data.code, data.codeSize)
            return repeatState().data({
                code: {$set: code},
                message: {$set: code.join('')},
            })
        }],

        // User pressed LOCK. CLose safe if code is long enough
        // else, repeat state (sets timeout on reentry)
        ['cast#lock#open/locking', ({data}) =>
            data.code.length !== data.codeSize ?
            repeatState() :
            nextState('closed/success').data({
                message: {$set: `**${data.code.join('')}**`},
            })],

        // Clear input when safe is closed
        ['enter#*_#closed', () => keepState().data({
            input: {$set: []},
            message: {$set: 'Locked'}
        })],

        // Postpone button press and go to closed/unlocking
        ['cast#button/*_#closed', ({}) =>
            nextState('closed/unlocking').postpone()],

        // User entered digit(s).
        // Keep state if code is not long enough
        // OPEN if input matches code
        // go to MESSAGE if code does not match and set a timeout
        ['cast#button/:digit#closed/unlocking', ({args, data}) => {
            let digit = Number(args.digit)
            let input = data.input.concat(digit)

            // code is the correct length. Decision time.
            if (input.length >= data.code.length) {
                let [state, msg] = arrayEqual(data.code, input) ?
                    ['open/success', "Opened"] :
                    ['closed/error', "ERROR"]

                return nextState(state).data({message: {$set: msg}})
            }

            // Not long enough. Keep collecting digits.
            // Show masked code. Repeat state for
            // setting timeout
            return repeatState().data({
                input: {$push: [digit]},
                message: {$set: "*".repeat(input.length)}
            })
        }],

        // These states timeout on inactivity (eventTimeout)
        [['enter#*_#open/locking',
            'enter#*_#closed/unlocking'], ({data}) =>
            keepState().eventTimeout(data.timeout)],

        // these states just timeout
        ['enter#*_#:state/*_', ({data}) =>
            keepState().timeout(data.timeout)],

        // If we timeout in a sub state, go to the base state
        [['genericTimeout#*_#:state/*_',
            'eventTimeout#*_#:state/*_',], ({args}) =>
            nextState(args.state)],
    ]

    initialData: SafeData = {
        code: [],
        codeSize: 4,
        timeout: 200,
        input: [],
    }

    initialState = 'open'

    constructor(timeout: Timeout) {
        super()
        this.initialData.timeout = timeout
    }

    /**
     * Safe Interface. casts 'reset'
     */
    reset() {
        this.cast('reset')
    }

    /**
     * Safe Interface. cast 'lock'
     */
    lock() {
        this.cast('lock')
    }

    /**
     * Safe Interface. send button digit
     * @param digit
     */
    button(digit: number) {
        this.cast({button: digit})
    }
}

```

Here’s the hotel safe’s state diagram:

![](https://github.com/venkatperi/hotelsafe/blob/master/hotel_safe.svg)