[![Build Status](https://travis-ci.org/venkatperi/statem.svg?branch=master)](https://travis-ci.org/venkatperi/statem)

# StateM
StateM is [Mealy ](https://en.wikipedia.org/wiki/Mealy_machine) state machine written in TypeScript and is largely based on Erlang OTP’s [gen\_statem](http://erlang.org/doc/design_principles/statem.html#event-time-outs "gen\_statem") behavior.

Online Demo: [Hotel Safe Simulator](https://hotel-safe.netlify.com/#/)

* States are arbitrary strings (except when they are not: see [ComplexState](#)).
* State machines are specified as an ordered list of handlers keyed by `Event x State` patterns.
* Events drive the state machine and are externally triggered or internally generated by the state machine. Pending events are  tracked on a priority queue that preserves entry order.
* State machines can hold arbitrary [data](#) which is provided to, and can be mutated by, its event handlers.

## Features
* Co-located code: Event, states, transitions and actions in one place.
* Inserted Events: Insert events from within the specification.
* State Entry Events: Automatically generates Entry events on state change.
* Timeouts: Install timeouts for state transitions, new events, or just plain timeouts.

## Processing Events
When processing events, the state machine looks for the first event handler whose key matches the `incoming event x current state`, or, a catch-all handler.

The matched handler is invoked with the incoming event, route matching arguments, the current state machine state and data.

The result of the handler invocation can include a state transition directive and transition actions, which are immediately executed, potentially changing the state machine’s state, mutating the internal data as well as the event queue.

# Routes
StateM adopts the same parameterized route matching seen in [express](www.expressjs.com) et. al. Incoming events are mapped to routes and matched against the state machine's handler routes.

## Incoming Event Routes
The current event and current state are mapped to a route string as:
```
<current event>#<event context>#<current state>
```

For example:


| Event | Event Context | Current State | Route |
|-------|---------------|---------------|-------|
| cast | `"flip"` | off | `"cast#flip#off"` |
| cast | `{button: 2}` | locked | `"cast#button/2#off"` |
| call | `"getInfo"` | one | `"call/internalId#getInfo/2#one"` |


## Handler Routes
In addition to the string literals used in incoming event routes, handler routes can include:
* Parameter capture patterns (`:param`) capture up to the next `/`, `#` or the end of the route.
* Splats (`*param`) capture from up to `#` or the end of the route.
* Parts of the route can be marked optional by wrapping in parenthesis. Optional parts can include parameter capture and splats.

For example:
* `cast#flip#:state` will match a `cast(flip)` event in any state and provide the current state as an argument (`args.param`) to the handler.
* `call/:from#getInfo#:state` will capture the callerId and state as `args.from` and `args.state` respectively.
* `"cast#button/:digit#locked` will capture a button press in the `locked` state and provide the digit value in `args.digit`.
* `"cast#*context#open` intercepts any `cast` events in state `open` regardless of the parameters passed when cast was invoked (note: the splat will be available as `args.context`).

# Event Types
## Call `call(request?: any)`
Sends an synchronous event to the state machine with an optional request and waits for the response.

The state machine looks for a handler for route:`call/<from>#<request>#<current state>`.

## Cast `cast(request?: any)`
Sends an asynchronous event to the state machine with an optional request and returns immediately, ignoring errors.

The state machine looks for a handler for route: `cast#<request>#<current state>`.

## Enter

## Timeout Events
### State Timeout

### Event Timeout

### Generic Timeout

## Internal

# Examples

See the `examples` directory for more examples.

## Toggle Button
ToggleButton is a simple state machine of a button that toggles between `off` and `on` when it’s toggle is flipped. It’s initial state is `off`.

```ts
class ToggleButton extends StateMachine {
	initialState = 'off'

	handlers: Handlers = [
		['cast#flip#off', 'on'],
		['cast#flip#on', 'off']
	]

	flip() {
		this.cast('flip')
	}
}
```

ToggleButton has a single event as its input, `cast('flip')` and no state transition actions.

1. `'cast#flip#off` —\> `on`
	i.e. in state `off`, if we receive event `cast('flip')`, transition to state `on`.

2. `'cast#flip#on` —\> `of`
	i.e. in state `on`, if we receive event `cast('flip')`, transition to state `off`.

```ts
let button = new ToggleButton()
button.startSM()

// initial state
console.log(await button.getState())	// 'off'

button.flip()
console.log(await button.getState())	// 'on'

button.flip()
console.log(await button.getState())	// 'off'
```

## Toggle Button With Count
ToggleButtonCount adds a counter to [ToggleButton](#) that counts the number of times it turned on.

```ts
export class ToggleButtonWithCount extends StateMachine {
	initialState = 'off'

	data = {
		count: 0
	}

	handlers: Handlers = [
		['cast#flip#off', ({data}) => nextState('on')
			.data({count: {$set: data.count + 1}})],

		['cast#flip#on', 'off']
	]

	flip() {
		this.cast('flip')
	}
}
```

ToggleButtonWith count adds a transition action when exiting `off` state.


```ts
let button = new ToggleButton()
button.startSM()

// initial state
console.log(await button.getState())	// 'off'

button.flip()
console.log(await button.getState())	// 'on'

button.flip()
console.log(await button.getState())	// 'off'
```

## Push Button

```ts
export class PushButton extends StateMachine {
	initialState = 'off'

	handlers: Handlers = [
		['cast#push#off', 'on'],
		['cast#release#on', 'off']
	]

	push() {
		this.cast('push')
	}

	release() {
		this.cast('release')
	}
}
```

## Push Button Countdown Timer

```ts
export class PushButtonCountdownTimer extends StateMachine {
	initialState = 'off'

	handlers: Handlers = [
		['cast#push#off', ({data}) => nextState('on').timeout(data.timeout)],
		['genericTimeout#*_#on', 'off']
	]

	constructor(timeout: Timeout) {
		super()
		this.data = {timeout}
	}

	push() {
		this.cast('push')
	}
}
```
